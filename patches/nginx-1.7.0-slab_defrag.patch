diff -r 48c97d83ab7f src/core/ngx_slab.c
--- a/src/core/ngx_slab.c	Tue Apr 29 22:22:38 2014 +0200
+++ b/src/core/ngx_slab.c	Wed May 07 13:01:57 2014 -0700
@@ -111,6 +111,7 @@
     ngx_memzero(p, pages * sizeof(ngx_slab_page_t));
 
     pool->pages = (ngx_slab_page_t *) p;
+    pool->npages = pages;
 
     pool->free.prev = 0;
     pool->free.next = (ngx_slab_page_t *) p;
@@ -118,6 +119,7 @@
     pool->pages->slab = pages;
     pool->pages->next = &pool->free;
     pool->pages->prev = (uintptr_t) &pool->free;
+    pool->pages->prev_slab = 0;
 
     pool->start = (u_char *)
                   ngx_align_ptr((uintptr_t) p + pages * sizeof(ngx_slab_page_t),
@@ -629,6 +631,7 @@
                 page[pages].slab = page->slab - pages;
                 page[pages].next = page->next;
                 page[pages].prev = page->prev;
+                page[pages].prev_slab = pages;
 
                 p = (ngx_slab_page_t *) page->prev;
                 p->next = &page[pages];
@@ -652,6 +655,7 @@
                 p->slab = NGX_SLAB_PAGE_BUSY;
                 p->next = NULL;
                 p->prev = NGX_SLAB_PAGE;
+                p->prev_slab = 0;
                 p++;
             }
 
@@ -672,7 +676,7 @@
 ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
     ngx_uint_t pages)
 {
-    ngx_slab_page_t  *prev;
+    ngx_slab_page_t  *prev, *p;
 
     page->slab = pages--;
 
@@ -686,6 +690,51 @@
         page->next->prev = page->prev;
     }
 
+    /* merge the next adjacent free block if it is free */
+
+    p = &page[page->slab];
+    if (p < pool->pages + pool->npages
+        && !(p->slab & NGX_SLAB_PAGE_START)
+        && p->next != NULL
+        && (p->prev & NGX_SLAB_PAGE_MASK) == NGX_SLAB_PAGE)
+    {
+        page->slab += p->slab;
+
+        /* remove the next adjacent block from the free list */
+
+        prev = (ngx_slab_page_t *) p->prev;
+        prev->next = p->next;
+        p->next->prev = p->prev;
+
+        ngx_memzero(p, sizeof(ngx_slab_page_t));
+
+        /* adjust the "prev_slab" field in the next next adjacent block */
+        if (p + p->slab < pool->pages + pool->npages) {
+            p[p->slab].prev_slab = page->slab;
+        }
+    }
+
+    if (page->prev_slab) {
+        /* merge the previous adjacent block if it is free */
+
+        p = page - page->prev_slab;
+        if (!(p->slab & NGX_SLAB_PAGE_START)
+            && p->next != NULL
+            && (p->prev & NGX_SLAB_PAGE_MASK) == NGX_SLAB_PAGE)
+        {
+            p->slab += page->slab;
+            ngx_memzero(page, sizeof(ngx_slab_page_t));
+
+            /* adjust the "prev_slab" field in the next adjacent block */
+            if (p + p->slab < pool->pages + pool->npages) {
+                p[p->slab].prev_slab = p->slab;
+            }
+
+            /* skip adding "page" to the free list */
+            return;
+        }
+    }
+
     page->prev = (uintptr_t) &pool->free;
     page->next = pool->free.next;
 
diff -r 48c97d83ab7f src/core/ngx_slab.h
--- a/src/core/ngx_slab.h	Tue Apr 29 22:22:38 2014 +0200
+++ b/src/core/ngx_slab.h	Wed May 07 13:01:57 2014 -0700
@@ -19,6 +19,8 @@
     uintptr_t         slab;
     ngx_slab_page_t  *next;
     uintptr_t         prev;
+    uintptr_t         prev_slab;
+                         /* number of pages for the previous adjacent block */
 };
 
 
@@ -31,6 +33,8 @@
     ngx_slab_page_t  *pages;
     ngx_slab_page_t   free;
 
+    ngx_uint_t        npages;
+
     u_char           *start;
     u_char           *end;
 
