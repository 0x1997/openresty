diff -r 7586e7b2dbe9 src/core/ngx_slab.c
--- a/src/core/ngx_slab.c	Tue Feb 18 17:30:40 2014 +0400
+++ b/src/core/ngx_slab.c	Tue May 06 14:00:13 2014 -0700
@@ -118,6 +118,7 @@
     pool->pages->slab = pages;
     pool->pages->next = &pool->free;
     pool->pages->prev = (uintptr_t) &pool->free;
+    pool->pages->prev_slab = 0;
 
     pool->start = (u_char *)
                   ngx_align_ptr((uintptr_t) p + pages * sizeof(ngx_slab_page_t),
@@ -628,6 +629,7 @@
                 page[pages].slab = page->slab - pages;
                 page[pages].next = page->next;
                 page[pages].prev = page->prev;
+                page[pages].prev_slab = pages;
 
                 p = (ngx_slab_page_t *) page->prev;
                 p->next = &page[pages];
@@ -651,6 +653,7 @@
                 p->slab = NGX_SLAB_PAGE_BUSY;
                 p->next = NULL;
                 p->prev = NGX_SLAB_PAGE;
+                p->prev_slab = 0;
                 p++;
             }
 
@@ -668,7 +671,7 @@
 ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
     ngx_uint_t pages)
 {
-    ngx_slab_page_t  *prev;
+    ngx_slab_page_t  *prev, *p;
 
     page->slab = pages--;
 
@@ -682,6 +685,53 @@
         page->next->prev = page->prev;
     }
 
+    /* try to merge the following free block (if any) */
+
+    p = &page[page->slab];
+    if ((u_char *) p < pool->start
+        && !(p->slab & NGX_SLAB_PAGE_START)
+        && p->next != NULL
+        && (p->prev & NGX_SLAB_PAGE_MASK) == NGX_SLAB_PAGE)
+    {
+        page->slab += p->slab;
+
+        /* remove the following block from the free list */
+
+        prev = (ngx_slab_page_t *) p->prev;
+        prev->next = p->next;
+        p->next->prev = p->prev;
+
+        ngx_memzero(p, sizeof(ngx_slab_page_t));
+
+        /* adjust prev_slab in the new following block accordingly */
+
+        if ((u_char *) (p + p->slab) < pool->start) {
+            p[p->slab].prev_slab = page->slab;
+        }
+    }
+
+    if (page->prev_slab) {
+        /* try to merge the preceding free block (if any) */
+
+        p = page - page->prev_slab;
+        if (!(p->slab & NGX_SLAB_PAGE_START)
+            && p->next != NULL
+            && (p->prev & NGX_SLAB_PAGE_MASK) == NGX_SLAB_PAGE)
+        {
+            p->slab += page->slab;
+            ngx_memzero(page, sizeof(ngx_slab_page_t));
+
+            /* adjust prev_slab in the following block accordingly */
+
+            if ((u_char *) (p + p->slab) < pool->start) {
+                p[p->slab].prev_slab = p->slab;
+            }
+
+            /* skip adding "page" to the free list */
+            return;
+        }
+    }
+
     page->prev = (uintptr_t) &pool->free;
     page->next = pool->free.next;
 
diff -r 7586e7b2dbe9 src/core/ngx_slab.h
--- a/src/core/ngx_slab.h	Tue Feb 18 17:30:40 2014 +0400
+++ b/src/core/ngx_slab.h	Tue May 06 14:00:13 2014 -0700
@@ -19,6 +19,7 @@
     uintptr_t         slab;
     ngx_slab_page_t  *next;
     uintptr_t         prev;
+    uintptr_t         prev_slab;
 };
 
 
